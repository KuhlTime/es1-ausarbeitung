<!DOCTYPE html>
<html>
	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta charset="utf-8" />
		<link rel="stylesheet" type="text/css" href="css/style.css" />
	</head>
<body>
<figure><img src="Artboard.png"/></figure>

<h1>Navitron - Ein Portabler Navigationskompass <br/><br/>Von der Planung bis zur Produktion</h1>

<h3>Ausarbeitung für Embedded Systems 1</h3>

<figure><img src="Profile.png"/></figure>

<ul>
	<li>Name: <strong>André Kuhlmann</strong></li>
	<li>Matrikelnummer: <strong>779690</strong></li>
	<li>Fachbereich: <strong>Elektro- und Informationstechnik <br/>Hochschule Düsseldorf</strong></li>
	<li>Erstellt: <strong>17. Juni 2020</strong></li>
	<li>Letztes Update: <b><span id="lastUpdated">Lädt ...</span></b> </li>
</ul>

<h2>Inhaltsverzeichnis</h2>

<div id="toc"></div>
<hr />

<h2>1. Einleitung</h2>

<p>Begonnen hat alles mit einer Mountainbike-Tour, mit meinem Vater. Die Tour die wir fahren wollten hatten wir zuvor in einer Outdoor-App auf unser Handy heruntergeladen doch trotz des elektronischen Helfers in der Tasche mussten wir alle paar Meter nach der richtigen Abzweigung ausschau halten. <br/>Da mir und meinem Vater das ständige rausholen des Handys irgendwann auf die Nerven ging machte ich mich im Internet nach einer Alternative schlau.<br/>Ich stieß damals auf einen Kickstarter Eintrag namens „<a href="https://www.kickstarter.com/projects/smarthalo/smarthalo-turn-your-bike-into-a-smart-bike?lang=de" title="SmartHalo"><em>SmartHalo</em></a>”.</p>

<p>Für mein Projekt in dem Modul Embedded Systems 1 werde ich nun versuchen eben jenes Produkt für mich und meinen Vater nachzubauen. Die Bauteile, wie den LED Ring oder den IMU habe ich glücklicherweise schon vorher gehabt und konnte diese direkt auf einem Breadboard testen. </p>

<p>Ich habe das Dokument in einige Themenbereiche gegliedert, in denen ich einzeln auf einige Besonderheiten des Projektes eingehe.</p>

<p>Da die Aufgabe darin bestand eine Audio- oder Videodatei aufzunehmen, nutze ich diese schriftliche Ausarbeitung als ein Skript für mein Video.</p>

<h3>1.1 Showcase</h3>

<p></p>

<hr />

<h2>2. Plannung</h2>

<ul>
	<li>Der Ring soll die Richtung anzeigen in die der Nutzer fahren soll</li>
	<li>Das Gerät sollte einen Akku eingebaut haben (LiPo)</li>
	<li>Die Abarbeitung der Route sowie die Ermittlung der GPS-Position soll das Gerät über eine Bluetooth Verbindung von dem Smartphone erhalten</li>
</ul>

<figure><img src="Artboard-1.png" alt="Aufgabenverteilung und Funktionsbausteine der beiden Geräte"/><figcaption>Aufgabenverteilung und Funktionsbausteine der beiden Geräte</figcaption></figure>

<figure><img src="IMG_0576.jpg" alt="Bestimmung der Größe des PCBs"/><figcaption>Bestimmung der Größe des PCBs</figcaption></figure>

<hr />

<h2>3. Umsetzung</h2>

<h3>3.1 Das Gerät</h3>

<p>Die Schaltung für das Gerät, welches schlussendlich am Lenker meines Fahrrads montiert werden soll habe ich in Eagle entworfen.</p>

<p>Im nachfolgenden werde ich näher auf die Wahl meiner verwendeten Bauteile eingehen.</p>

<h4>3.1.1 Mikrocontroller</h4>

<figure><img src="3320-06.jpg"/></figure>

<p>Als Herz meiner Schaltung habe ich mich für einen <strong>ESP32</strong> der Firma Espressif entschieden, da ich bereits häufiger mit diesem Mikrocontroller gearbeitet habe und er bereits über die nötige Bluetooth Schnittstelle verfügt.<br/>Anders als viele Atmel Mikrocontroller läuft dieser nicht auf den üblichen $5$ Volt sondern $3.3$ Volt. Für die Aufgabe ist dieser Mikrocontroller sehr wahrscheinlich überdimensioniert und könnte wahrscheinlich durch einen sparsameren Mikrocontroller ersetz werden. Zeit war hier ein entschiedener Faktor.</p>

<h4>3.1.2 LED-Ring</h4>

<figure><img src="2856-01.gif" alt="https://www.adafruit.com/product/2856"/><figcaption>https://www.adafruit.com/product/2856</figcaption></figure>

<p>Für den LED-Ring verwendet ich <strong>WS2812B</strong>.<br/>Diese von der Firma Worldsemi hergestellten RGB-LEDs sind einzeln ansteuerbare LEDs die über einen Datenpin ihre gewünschte Farbe erhalten. Jede weitere LED kann über den Datenausgang in Reihe verschaltet werden.<br/>Für die LEDs wird eine Spannung von $3.5\text{V}\ bis\ 5.3\text{V}$ benötigt, welche ohne einen Spannungsbooster für die Batterie möglich seien sollte. Mit geringerer Spannung kommt es zu deutlich erkennbaren Farbverfälschung. <br/>Das ansteuern mit den $3.3\text{V} $ des ESP Ausgangs hat bei meinen Tests ohne Probleme funktioniert. Falls es hier allerdings zu Problemen mit dem ansteuern der LEDs kommt müsste eventuell ein passender Level Shifter verwendet werden.</p>

<h4>3.1.3 USB to Serial Converter</h4>

<p>Um ein schnelles umprogrammieren des Mikrocontrollers zu ermöglichen habe ich mich für die Verwendung eines USB to Serial Converter entschieden. Damit lassen sich Programmupdates ohne großen Aufwand direkt auf den Chip des Navitron flashen. Für das Design habe ich auf Open Source Schaltungen der Firma <a href="https://www.sparkfun.com/products/15006?utm_campaign=LoRa%20Gateway%20ESP32&amp;utm_source=2nd%20Featured%20Content">Sparkfun</a> zurückgegriffen. </p>

<h3>3.2 Die App</h3>

<p>Neben dem eigentlichen Gerät habe ich mich dafür entschieden die Positionsbestimmung sowie die Einpflegung und Verarbeitung der Route über ein verbundenes Smartphone zu realisieren. Schlussendlich wird der errechnete Kurs dann über Bluetooth an das Gerät übertragen, so dass schlussendlich nur der gewünschte und der momentane Kurs von dem Gerät verglichen werden muss.</p>

<hr />

<h2>4. Beschreibung</h2>

<p>In diesem Teil gehe ich etwas tiefer auf einige Konzepte und Bauteile ein, die für die Umsetzung dieses Projektes von Nöten sind.</p>

<h3>4.1 Inertiale Messeinheit (IMU)</h3>

<p>Als <em>Inertiale Messeinheit</em> (engl.: „<em>Inertial Measurment Unit</em>”, kurz: <em>IMU</em>) beschreibt man einen Sensor, mit welchem die Lage und Bewegung im Physikalischen Raum festgestellt werden kann. Ein solcher Sensor beinhaltet überlicherweise einen <em>Beschleunigungssensor</em> und einen <em>Drehratensensor</em>. Für meine Anwendung ist neben diesen beiden Sensoren auch ein <em>Magnetfeldsensor</em> vorhanden, welches — wenn den richtig kalibriert — das magnetische Feld der Erde erfassen soll.</p>

<p>Man spricht von einem Sensor mit 9 Freiheitsgeraden (9 DOF — Dimension of Freedom)</p>

<h3>4.2 Magnetische Störungen</h3>

<p>Um das Erdmagnetfeld richtig erfassen zu können, müssen zu beginn sämtlich magnetischen Störgrößen erfasst und herausgerechnet werden. Dieser Prozess ist als „Kalibrieren des Sensors” bekannt und muss auch bei einem Smartphone vor der Verwendung des Kompass durchgeführt werden. <sup><a id="ffn1" href="#fn1" class="footnote">1</a></sup> </p>

<p>Es gibt zwei Art von auftretenden Störgrößen: </p>

<p><strong>Hard Iron Distortion</strong></p>

<p><em>Hard Iron Sources</em> sind Magnetfelder die sich mit dem Sensor bewegen und so für eine konstant gleiche Verfälschung der Daten sorgen. Mögliche Gründe dafür sind benachbarte, ferromagnetische Bauteile auf dem PCB oder im Gehäuse.</p>

<p><strong>Soft Iron Distortion</strong></p>

<p></p>

<p><br/></p>

<p><sup><a id="ffn2" href="#fn2" class="footnote">2</a></sup></p>

<h3>4.3 Das Erdmagnetfeld</h3>

<p>Nachdem wir die magnetischen Störgrößen herausgefiltert haben werden wir schnell feststellen, dass die gemessenen Daten unseres Magnetometers nicht in Richtung geographischen Norden zeigen werden.</p>

<div class="block" style="position: relative;">	
	<p class="block-title">Unterschied zwischen Geographischem und Magnetischem Nordpol</p>
	<div style="display: flex; position: relative; align-items: flex-start;">
		<p style="flex: 1 1 0; flex-basis: 100%; margin-right: 8px;">Wohingegen der Geogeraphische Nordpol immer an der selben stelle zu finden ist, verschiebt sich der Magnetische Nordpol jedes Jahr um ein paar Kilometer.
		</p>

		<img style="flex: 1 1 0; flex-basis: 100%; width: 0; overflow: hidden; border-radius: 4px;" src="https://www.dw.com/image/47043001_7.png">
	</div>
</div> 
<p><br/>Der Grund für die Abweichung zwischen dem magnetischen und geographischen Norden ist, dass sich unser Schutzschild (das Erdmagnetfeld) permanent verändert und verschiebt. <br/>Zu allem Übel verlaufen die Erd-Magnetfeldlinien auf unserem Breitengrad nicht Horizontal zur Erdoberfläche sondern versinken in einem bestimmten Winkel in die Erde. Dieser Winkel wird die magnetische <em>Inklination</em> gennant. Auf Nachfolgender Karte, von den <em>National Centers for Enviormental Information</em> (kurz: <em>NOAA</em>) lässt sich dieser Wert für jeden Ort der Erde ablesen. <sup><a id="ffn3" href="#fn3" class="footnote">3</a></sup></p>

<figure><img src="WMM2020_I_BoZ_MILL.pdf.jpg" alt="Karte für die Ende 2019 gemessene magnetische Inklination"/><figcaption>Karte für die Ende 2019 gemessene magnetische Inklination</figcaption></figure>

<p>Als <em>Deklination</em> wird der Winkel zwischen magnetischem und geographischen Norden bezeichnet. Es ist also die Abweichung zwischen den beiden.</p>

<p>Bei einer Deklination von bspw. 10° an unserer Position hätte das zur folge, dass wenn wir einen Kompass betrachten die Nadel leicht nach rechts zeigen müsste, damit wir in Richtung Norden schauen. </p>

<p>Da unser Gerät natürlich in Richtung des geographischen Nordens ausgerichtet seien soll müssen wir diese Abweichung später mit in unsere Berechnung mit einfließen lassen.</p>

<figure><img src="WMM2020_D_BoZ_MILL.pdf.jpg" alt="Karte für die Ende 2019 gemessene magnetische Deklanation"/><figcaption>Karte für die Ende 2019 gemessene magnetische Deklanation</figcaption></figure>

<p>Die Inklination und Deklination kann im folgenden für die angegebenen Koordinaten berechnet werden. Die Daten kommen von <a href="https://amentum.space/">Amentum Aerospace</a> (<a href="https://globalmagnet.amentum.space/wmm/ui/#!/Click32to32view32documentation32for32API32endpoints/app_api_wmm_endpoints_WMM_magnetic_field">API</a>). </p>

<input style="margin-top: 20px" class="input" type="decimal" placeholder="Latitude" id="lat" required>
<input class="input" type="decimal" placeholder="Longitude" id="lng" required>
<button id="magBtn" onclick="loadMagData()">Laden</button>

<p style="text-align: center; background-color: #eee; padding: 4px; border-radius: 4px; display: none;" id="magData">Die Deklination an diesem Ort beträgt: <b>2,4°</b></p>
<p><p style="font-size: 80%; color: #555; text-align: center">Das Ergebnis wird mit einem "." als Komma dargestellt.</p></p>

<h3>4.4 GPS </h3>

<p>Die Ermittlung der aktuellen GPS-Koordinaten, des Nutzers erfolgt über die zum Gerät zugehörige Smartphone App. Diese Architektur ist zwar nicht gerade Nutzerfreundlich aber schneller für mich zu realisieren, da das Smartphone bereits mit einigen Bibliotheken für die Verwendung des integrierten GPS Moduls kommt.</p>

<hr />

<h2>5. Berechnungen</h2>

<h3>5.1 Route</h3>

<p>Die Route liegt im Handy als Liste von Wegpunkten, als eine <em>GPX Datei</em>, vor. Jeder Wegpunkt besitzt eine Koordinate, welche nacheinander die gewünschte Tour ergibt.</p>

<p>Kommt der Nutzer einem Wegpunkt nahe so soll automatisch der nächste Wegpunkt ausgewählt werden. </p>

<p>In dem nachfolgenden Konzept wird die aktuelle Position des Nutzers mit dem Blauen Punkt dargestellt. Der Blau Transparente Kreis ist der Detektionsradius in welchem ein Wegpunkt erkannt und der nächste Wegpunkt ausgewählt wird.</p>

<figure><img src="Artboard-2.png" alt="Konzept zur Abarbeitung einer Route"/><figcaption>Konzept zur Abarbeitung einer Route</figcaption></figure>

<p>Eine mögliche Überprüfung, ob sich die Person in Reichweite eines Wegpunktes befindet könnte wie folgt in <strong>Swift</strong> umgesetzt werden. Es handelt sich hier um Pseudocode und funktioniert so noch nicht direkt in der App.</p>

<pre><code class="code-highlighted code-swift"><span class="syntax-all syntax-comment">/**
</span><span class="syntax-all syntax-comment"> Die Funktion prüft ob sich der Wegpunkt (wp) im Radius 
</span><span class="syntax-all syntax-comment"> (radius) der aktuellen Position des Nutzers (pos) 
</span><span class="syntax-all syntax-comment"> befindet und gibt das Ergebnis als Boolean zurück.
</span><span class="syntax-all syntax-comment"> */</span>

<span class="syntax-all syntax-keyword">func</span> <span class="syntax-all syntax-entity">checkInBounds</span>(
	<span class="syntax-all syntax-entity">pos</span>: Coordinate, 
	<span class="syntax-all syntax-entity">wp</span>: Coordinate, 
	<span class="syntax-all syntax-entity">radius</span>: <span class="syntax-all syntax-constant">Double</span>
) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Bool</span> {
	<span class="syntax-all syntax-comment">// Die Entfernung zwischen der Position und dem 
</span>	<span class="syntax-all syntax-comment">// Wegpunkt
</span>	<span class="syntax-all syntax-keyword">let</span> entfernung <span class="syntax-all syntax-keyword">=</span> pos.<span class="syntax-all syntax-constant">distance</span>(<span class="syntax-all syntax-constant">to</span>: wp)

	<span class="syntax-all syntax-comment">// Prüfen pb die Entfernung zum Wegpunkt kleiner ist
</span>	<span class="syntax-all syntax-comment">// als der Detektionsradius
</span>	<span class="syntax-all syntax-keyword">return</span> entfernung <span class="syntax-all syntax-keyword">&lt;</span> radius
}</code></pre>

<p>Da vielleicht aufgrund von Ungenauigkeiten bei der GPS Bestimmung die Auswahl des Wegpunktes fehlschlägt, soll es in der App die Möglichkeit geben den nächsten Wegpunkt manuell auszuwählen.</p>

<h3>5.2 Entfernung zweier Koordinaten</h3>

<p>Um automatisch den nächsten Wegpunkt auszuwählen muss die Entfernung zum nächsten Wegpunkt bestimmt werden. Bei Koordinaten handelt es sich um Positionen auf einer Kugeloberfläche. Gehen wir davon aus, dass die Erde eine glatte Kugel ist so lässt sich die Erde mit der Funktion $x^2+y^2+z^2=(6378.13 \text{km})^2$ darstellen. </p>

<div class="block" style="position: relative;">	
	<p class="block-title">Erdellipse statt Erdkugel?</p>
	<div style="display: flex; position: relative; align-items: flex-start;">
		<p style="flex: 1 1 0; flex-basis: 100%; margin-right: 8px;">Tatsächlich ist die Erde aufgrund der durch die Erdrotation auftretenden Fliehkräfte keine perfekt Kugel sondern ist zum Equator hin gestreckt. Das Bild rechts zeigt eine überzogene Darstellung dieser Ausdehnung. Tatsählich liegen die maximale Stauchung und maximale Streckung lediglich 22km auseinander. Was bezogen auf den Erdradius eine Differenz von 0,3% ausmacht und daher für unsere Berechnungen keinen all zu großen Einfluss haben sollte.
	<br>
<a href="https://gis.stackexchange.com/a/25580">StackExchange (Geographical Information Systems)</a>
</p>
<img style="flex: 1 1 0; flex-basis: 50%; width: 0; overflow: hidden; border-radius: 4px;" src="https://upload.wikimedia.org/wikipedia/commons/b/b5/OblateSpheroid.PNG">	
</div>
</div>
<p>Die $6378.13km$ (<a href="[https://www.wolframalpha.com/input/?i=earthradius]">WolframAlpha</a>) entsprechen dabei der Strecke vom Erdmittelpunkt bis hin zum Erdmantel, also dem Radius r der Erde.</p>

<figure><img src="kugel.svg" alt="Radius r der Erdkugel"/><figcaption>Radius r der Erdkugel</figcaption></figure>

<p>Zur Entfernungsberechnung müssen die geographischen <em>zwei dimensionalen</em> Koordinaten (lat, lng) in <em>drei dimensionale</em> ellipsoidische Koordinaten (x, y, z) umgewandelt werden. Dies ergibt einen Punkt auf der Kugeloberfläche.</p>

<p>Um nun die Distanz zwischen den zwei sich auf der Kugel befindlichen Koordinaten zu finden.</p>

<p>(Berechnung) <sup><a id="ffn4" href="#fn4" class="footnote">4</a></sup></p>

<h3>5.3 Magnetometer Kalibrierung</h3>

<p>Die Kalibrierung, des Magnetfeldsensors dient dazu sämtlich Störgrößen zu ermitteln und schlussendlich aus den Messdaten herauszufiltern. <br/>Welche Störgrößen es zu beachten gibt hatte ich bereits im Teil „<a href="#magnetischeStörungen">Magnetische Störungen</a>” näher erläutert.</p>

<p><strong>Hard-Ironing</strong></p>

<p>Sorgt für eine Verschiebung des Zentrums der Messdaten.</p>

<p><strong>Soft-Ironing</strong></p>

<p>Sorgt für eine Streckung bzw. Stauchung der Messdaten.</p>

<p></p>

<p>Für die Kalibrierung habe ich ein entsprechendes Python Programm geschrieben, dass mir sowohl die Ausgleichswert für das später auf den Mikrocontroller laufende Programm ausrechnet als auch visuell die Abweichung der Messdaten in einem Koordinatensystem darstellt. </p>

<p></p>

<p></p>

<h3>5.4 Magnetometer Kursbestimmung</h3>

<h3>5.3 Laufender Betrieb</h3>

<p>Um die Inklination des Magnetfeldes zu kompensieren und die dreidimensional vorliegenden Daten in eine zweidimensionale Form, wie bei einem Kompass zu überführen muss…</p>

<hr />

<h2>6. Schaltung</h2>

<p>Wie auch im Praktikum habe ich für die Erstellung der Platine das von Autodesk kostenlos zu Verfügung stehende Programm Eagle verwendet. Mit diesem Programm habe ich mehrmals andere, kleinere Schaltungen entworfen und bin mit diesem am besten vertraut. Das Design basiert größtenteils auf Open Source zugängliche Designs der Firma <a href="https://www.sparkfun.com/">Sparkfun</a>. Einige der verwendeten Bauteile habe ich bereits vorher besessen und konnte diese auf einem Breadboard verwenden um einige Design Features im voraus zu testen.</p>

<figure><img src="Navitron%20Seite%202.jpg"/> <img src="Navitron%20Seite%201.jpg"/></figure>

<h3>6.1 Korrektur</h3>

<p>Da ich sichergehen wollte, dass meine Schaltung auch wirklich in vollem Umfang funktioniert, habe ich auf der Freelancer Platform <a href="https://de.fiverr.com/knochi/design-your-custom-electronics?context_referrer=search_gigs&amp;source=your_recently_viewed_gigs&amp;ref_ctx_id=9039e438-964f-4fa9-b083-d1eeb5000c71&amp;pckg_id=1&amp;pos=2&amp;is_pro=false&amp;context_alg=recently_viewed&amp;context=recommendation">Fiverr</a> für ein paar Euro jemanden beauftragt meine Schematic auf Fehler zu überprüfen. Neben einem Widerstand und einem Entkopplungskondensator hat er allerdings keine Fehler feststellen können. Was genau ich an Hilfe bekommen habe können Sie sich ebenfalls in meinem Repository anschauen (damit Sie sehen, dass es mit rechten Dingen zugegangen ist).</p>

<p>Das PCB habe ich zu 100% selber erstellt und ist bis auf einen Entkopplungskodensator hoffentlich funktionsfähig. </p>

<figure><img src="IMG_0579.jpg" alt="Überprüfung jedes Pins des PCB anhand der Schemtischen Schaltung"/><figcaption>Überprüfung jedes Pins des PCB anhand der Schemtischen Schaltung</figcaption></figure>

<h3>6.2 Herstellung</h3>

<p>Bei all meinen bisher erstellten Boards habe ich auf den Chinesischen Hersteller JLCPCB zurückgegriffen. Aus Umweltgründen würde ich gerne einen Deutschen oder doch zumindest Europäischen Hersteller vorziehen konnte aber keine kostengünstige Alternative finden. Selbst mit Expresslieferung ist die Produktion in Fernost um einiges billiger. Auch aufgrund meines doch eher beschränkten Budget für diese Projekt musste ich leider die Umwelttechnischen Konsequenzen ausser acht lassen. Für eine nächste Version, welche ich ohne Zeitdruck entwickeln könnte wäre dies jedoch ein Hauptmerkmal. </p>

<figure><img src="Top.png" alt="Obere Fotomaske für die Photolithografie"/><figcaption>Obere Fotomaske für die Photolithografie</figcaption></figure>

<h3>6.3 Montage</h3>

<p>Neben dem eigentlichen PCB habe ich zudem eine Schablone für das Auftragen der Lötpaste bestellt. Diese ist mit einem Spachtel auf das Board aufzubringen und kann dann mit einem Reflow-Ofen oder einem Heißluftföhn zum schmelzen gebracht werden. Die Komponenten sind vorher vorsichtig auf die entsprechende Stelle zu platzieren.</p>

<p>Am meisten sorgen bereitet mir der IMU Sensor der mit seinen gerade einmal 3x3mm mit ganzen 24 Pins eine echte Herausforderung herausstellt. Auch der doch recht hohe Preis von 7,13$\frac{\text{€}}{\text{Stück}}$ lässt wenig Fehlerspielraum zu. </p>

<figure><img src="IMG_0578.jpg" alt="ICM-20948 neben einem Lineal und ein paar Staub-Flusen"/><figcaption>ICM-20948 neben einem Lineal und ein paar Staub-Flusen</figcaption></figure>

<h3>6.4 Verbesserung</h3>

<p>Eine eventuelle Nachfolger Version des Gerätes sollte folgendes beinhalten:</p>

<ul>
	<li>Das Logo, welches ich vergessen habe auf das PCB zu packen.</li>
	<li>Aus Zeitgründen habe ich es Bissher nicht geschafft ein geeignetes Case zu entwerfen. Dieses sollte wenn möglich Wasserresistent sein um das Gerät vor Spritzwasser und regen zu schützen.</li>
	<li>Kleine Komponenten mit einem per Pick and Place Service aufbringen lassen. Dafür bietet JLCPCB einen entsprechenden Service an. Eventuell müssen andere Komponenten verwendet werden.</li>
	<li>Kalibrierungsprogramm in finales Programm integrieren</li>
</ul>

<hr />

<h2>7. Bauteilliste</h2>

<p>Neben den verwendeten Bauteilen habe ich auch den Grund für die Verwendung sowie einige zusätzliche Ressourcen angegeben. Die Bauteile habe ich alle bei Digi-Key bestellt.</p>

<ul>
	<li>Mikrocontroller: <a href="https://www.espressif.com/en/products/socs/esp32/overview">ESP32-WROOM-32U</a> (<a href="https://www.espressif.com/sites/default/files/documentation/esp32_datasheet_en.pdf">ESP32 Datasheet</a>, <a href="">esp32.net</a>)

		<ul>
			<li>Ich habe mich für diesen Mikrocontroller entschieden da er bereits mit einem eingebauten Bluetooth Modul daherkommt.</li>
		</ul></li>
	<li>Akku: 3,7V Lithium-Polymer-Akku</li>
	<li>IMU: <a href="https://invensense.tdk.com/products/motion-tracking/9-axis/icm-20948/">ICM-20948</a></li>
	<li>LED Ring: <a href="https://www.adafruit.com/product/1463">Adafruit 16 LED NeoPixel Ring</a></li>
</ul>

<h3>7.1 Kosten</h3>

<p>Die Kosten pro Board belaufen sich auf etwa 15€ bis 20€. Da ich Ersatz Komponenten für 3 Boards und einiges an zusätzlichem Werkzeug bestellt habe lagen meine Anschaffungskosten bei etwa 150€. Mit zunehmender Abnahmemenge and PCB-Boards und Komponenten kann dieser Preis allerdings noch deutlich verringert werden. Damit liegt meine Ausgabe über den 139€ für den SmartHalo habe aber durch das entwerfen einiges an Erfahrung gewonnen und kann nun auch für meine Familie einen solchen Fahrradcomputer erstellen.</p>

<hr />

<h2>8. Danksagung</h2>

<ul>
	<li>Danke an <a href="https://www.sparkfun.com/">Sparkfun</a> für das ihre Open Source zugänglichen Schaltungen.</li>
	<li>Danke an <a href="https://de.fiverr.com/knochi/design-your-custom-electronics?context_referrer=search_gigs&amp;source=your_recently_viewed_gigs&amp;ref_ctx_id=9039e438-964f-4fa9-b083-d1eeb5000c71&amp;pckg_id=1&amp;pos=2&amp;is_pro=false&amp;context_alg=recently_viewed&amp;context=recommendation">Knochi</a> der mir die Korrektur für meine Schaltung geliefert hat.</li>
	<li>Adafruit</li>
</ul>

<hr />

<h2>9. Quellenverzeichnis</h2>

<blockquote>
<p>Die Bauteile Bibliotheken habe ich mir auf <a href="https://www.snapeda.com/">SnapEDA.com</a> heruntergeladen.</p>
</blockquote>

<script>
/* Preferences */

let min = 2
let max = 6

let blacklist = [
  'Inhaltsverzeichnis',
  'Ausarbeitung für Embedded Systems 1'
]

/* =========== */

var headers = []

window.onload = function() {
	loadLastUpdatedBitbucket('kuhltime', '')
  	generateTableOfContent()
}


/* Functions */

function loadLastUpdatedBitbucket(user, repo) {
	let $field = document.getElementById('lastUpdated')
	let url = `https://api.bitbucket.org/2.0/repositories/${user}/${repo}/`

	fetchAsync(url)
		.then(data => { 
			let updated = new Date(data.updated_on)

			console.log(data)

			let options = { 
				year: 'numeric', 
				month: 'long', 
				day: 'numeric'
			}
	
			$field.innerHTML = updated.toLocaleDateString('de-DE', options)
		})
		.catch(error => { 
			$field.innerHTML = 'Repository is Marked Private'
			$field.style.color = '#FD2220'
			console.error(error)
			console.error('The is unavailable or marked as private')
		})
}

function generateTableOfContent() {
	let $toc = document.getElementById('toc')

	$toc.innerHTML = 'Lädt ...'

	// gets all the headers that are available
  headers = getHeaders(min, max)
	
  // The html string that gets populated and later displayed inside the
  // table of content #toc element
  var html = ''
  
  // The previousValue stores the depth of the last header
  var previousValue = min - 1

  headers.forEach(($header, index) => {
  	// Get values
    let headerValue = parseInt($header.localName.charAt(1))
    let difference = previousValue - headerValue
    let title = $header.innerHTML
    let camelTitle = toCamelCase(title)

		// Check if title is blacklisted
    if (blacklist.includes(title)) {
      return
    }
    
    // Update header id
    $header.id = camelTitle

    var i = 0

		// Add wrapper
    if (difference > 0) {
      // Go out
      for (i; i < Math.abs(difference); i++) {
        html += '</ul>'
        previousValue--
      }

    } else if (difference < 0) {
      // Go in
      for (i; i < Math.abs(difference); i++) {
        html += '<ul>'
        previousValue++
      }
    }

		// Add list item
    html += `<li><a href="#${camelTitle}">${title}</a></li>`
  })

  $toc.innerHTML = html
}

function loadMagData() {
	const lat = parseFloat(document.getElementById('lat').value)
	const lng = parseFloat(document.getElementById('lng').value)


	if (lat == NaN || lng == NaN) {
		console.error('Invalid data')
		return
	}

	const year = new Date().getFullYear()	

	const url = `https://globalmagnet.amentum.space/wmm/magnetic_field?altitude=0&latitude=${lat}&longitude=${lng}&year=${year}`
	const $field = document.getElementById('magData')

	const $btn = document.getElementById('magBtn')
	$btn.innerHTML = "Lädt..."
	$btn.disabled = true

	fetchAsync(url)
		.then(data => {
			console.log(data)
			const dec = data.declination.value.toFixed(1)
			const inc = data.inclination.value.toFixed(1)
			const strength = (data.total_intensity.value / 1000).toFixed(0)

			$field.innerHTML = `Deklination: ${dec}°<br>Inklination: ${inc}°<br>Stärke: ${strength}mT`
			$field.style.display = "block"
			$field.style.color = 'black'

			$btn.innerHTML = "Laden"
			$btn.disabled = false
		})
		.catch(error => {
			console.error(error)
			$field.innerHTML = "Error. Open up console for more information!"
			$field.style.display = "block"
			$field.style.color = '#FD2220'

			$btn.innerHTML = "Laden"
			$btn.disabled = false
		})
}

function getHeaders(min, max) {
  var tagNames = ''
  var i = min

  for (i; i <= max; i++) {
    tagNames += `h${i}`
    if (i != max) {
      tagNames += ','
    }
  }

  return document.querySelectorAll(tagNames)
}

// https://stackoverflow.com/a/2970588/4179020
function toCamelCase(str) {
  return str
    .replace(/\s(.)/g, function($1) {
      return $1.toUpperCase();
    })
    .replace(/\s/g, '')
    .replace(/^(.)/, function($1) {
      return $1.toLowerCase();
    });
}

//https://gist.github.com/msmfsd/fca50ab095b795eb39739e8c4357a808 
// async function
async function fetchAsync (url) {
  // await response of fetch call
  let response = await fetch(url);
  // only proceed once promise is resolved
  let data = await response.json();
  // only proceed once second promise is resolved
  return data;
}

/* ========= */
</script>
<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath:[['$','$']]}});</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=default' async></script>
<ol id="footnotes">
	<li id="fn1">Douglas, B. (2019). Understanding Sensor Fusion and Tracking, Part 2: Fusing a Mag, Accel, &amp; Gyro Estimate. MatLab auf YouTube. Zugriff: 17. Juni 2020 <br/><a href="">https://www.youtube.com/watch?v=0rlvvYgmTvI</a> <a href="#ffn1">&#x21A9;&#xFE0E;</a></li>
	<li id="fn2">Wahdan, A., Georgy, J., Abdelfatah, W.F. and Noureldin, A. (2014). Magnetometer Calibration for Portable Navigation Devices in Vehicles Using a Fast and Autonomous Technique. IEEE Transactions on Intelligent Transportation Systems, 15(5), p.2. Zugriff: 20. Juni 2020<br/><a href="">https://www.researchgate.net/publication/266082960_Magnetometer_Calibration_<br/>for_Portable_Navigation_Devices_in_Vehicles_Using_a_Fast_and_<br/>Autonomous_Technique</a> <a href="#ffn2">&#x21A9;&#xFE0E;</a></li>
	<li id="fn3">National Centers for Environmental Information (NCEI) (2019). World Magnetic Model. Noaa.gov. Zugriff: 18. Juni 2020. <br/><a href="">https://www.ngdc.noaa.gov/geomag/WMM/</a> <a href="#ffn3">&#x21A9;&#xFE0E;</a></li>
	<li id="fn4"><a href="https://www.movable-type.co.uk/scripts/latlong.html">https://www.movable-type.co.uk/scripts/latlong.html</a> <a href="#ffn4">&#x21A9;&#xFE0E;</a></li>
</ol></body>
</html>

